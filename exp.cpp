#include <iostream>      // Подключение библиотеки для ввода/вывода
#include <vector>        // Подключение библиотеки для работы с динамическими массивами (векторами)
#include <fstream>       // Подключение библиотеки для работы с файлами
#include <sstream>       // Подключение библиотеки для работы с потоками строк

using namespace std;     // Использование стандартного пространства имён

// Объявление класса T
class T
{
    int P;             // Переменная для хранения какого-то параметра
    int *v;            // Указатель на массив целых чисел
public:
    int n;             // Число элементов в массиве
    
    // Конструктор с параметром P и количеством элементов n (по умолчанию n = 0)
    T(int P, int n=0) {
        if (n) {   // Если n не равно нулю
            this->P = P;    // Присваиваем P значение параметра
            v = new int[this->n = n];   // Выделяем память для массива v размером n
            for (int i = 0; i < n; i++) {
                v[i] = int();   // Инициализируем все элементы массива значением по умолчанию (0)
            }
        } else {
            SetZero();  // Если n равно 0, вызываем SetZero для очистки
        }
    }

    // Конструктор по умолчанию, который вызывает SetZero для установки начальных значений
    T() { SetZero(); }

    // Деструктор для очистки ресурсов
    ~T() { Clean(); }

    // Конструктор копирования
    T(const T& b) { CopyOnly(b); }

    // Оператор присваивания с проверкой на самоприсваивание
    T& operator=(const T& b) {
        if (&b != this) {    // Проверка на самоприсваивание
            Clean();         // Освобождаем старые ресурсы
            CopyOnly(b);     // Копируем данные из объекта b
        }
        return *this;
    }

    // Метод для установки всех данных объекта в ноль (очистка)
    void SetZero() {
        v = nullptr;    // Указатель на массив становится нулевым
        n = 0;          // Число элементов = 0
        P = 0;          // Значение P = 0
    }

    // Метод для очистки памяти и установки нулевых значений
    void Clean() {
        delete[] v;  // Освобождение памяти, занятой массивом v
        SetZero();    // Установка всех данных в ноль
    }

    // Метод для копирования данных из объекта b
    void CopyOnly(const T& b) { 
        if (b.n != 0) {   // Если размер массива больше 0
            v = new int[n = b.n];    // Выделяем память для нового массива
            for (int i = 0; i < n; i++) {
                v[i] = b.v[i];   // Копируем элементы из массива объекта b в текущий
            }
            P = b.P;  // Копируем значение P
        } else {
            SetZero();  // Если n = 0, очищаем объект
        }
    }

    // Конструктор, принимающий вектор целых чисел
    T(const vector<int>& b) {
        if (!b.empty()) {    // Если вектор не пуст
            this->n = b.size() - 1;   // Размер массива - 1, так как первый элемент это P
            v = new int[n];   // Выделяем память для массива
            P = b[0];         // Первый элемент вектора - это P
            for (int i = 0; i < this->n; i++) {
                v[i] = b[i + 1];   // Копируем все элементы вектора в массив v (кроме первого)
            }
        } else {
            SetZero();  // Если вектор пуст, очищаем объект
        }
    }

    // Оператор индексации для изменения элементов массива (не для const объектов)
    int& operator[](int i) {
        if (i >= n) { cout << i << " bad index"; }   // Проверка на выход за пределы массива
        return v[i];  // Возвращаем элемент массива по индексу
    }

    // Оператор индексации для доступа к элементам массива (для const объектов)
    const int& operator[](int i) const { return v[i]; }

    // Метод для сортировки массива в зависимости от значения P
    void sort() {
        if (n == 0) return;  // Если массив пуст, ничего не делаем
        if (P == 1) {   // Если P = 1, сортируем по убыванию
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (v[j] < v[j + 1]) {   // Если элемент j меньше следующего, меняем их местами
                        swap(v[j], v[j + 1]);
                    }
                }
            }
        } else {   // Если P != 1, сортируем по возрастанию
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (v[j] > v[j + 1]) {   // Если элемент j больше следующего, меняем их местами
                        swap(v[j], v[j + 1]);
                    }
                }
            }
        }
    }

    // Метод для вывода объекта в поток (например, в файл)
    void print(ostream& os) const {
        os << P << '\t';   // Сначала выводим значение P
        for (int i = 0; i < n; i++) {
            os << v[i] << ' ';   // Затем выводим все элементы массива
        }
        os << '\n';   // Перенос строки в конце
    }
};

// Главная функция
int main() {
    ofstream out("data.res");  // Открытие файла для вывода
    T* matrix = nullptr;  // Указатель на массив объектов класса T
    int n = 0;  // Количество строк (объектов T)

    // Чтение данных из двух файлов
    for (int I = 0; I < 2; I++) {
        ifstream in("data.dat");   // Открытие файла для чтения
        if (!in) {  // Если файл не открылся, выводим ошибку
            out << "ERROR" << endl;
            return -1;
        }
        string line;
        if (I == 0) {   // В первом цикле (I == 0) считаем количество строк
            while (getline(in, line)) {
                if (line.empty()) { continue; }
                n++;  // Увеличиваем счётчик строк
            }
            matrix = new T[n];  // Создаём массив объектов T размером n
        } else {   // Во втором цикле (I == 1) считываем данные и заполняем массив
            int i = 0;
            int all = 0, max_elem = 0, n_elem;
            while (getline(in, line)) {
                int value;
                if (line.empty()) { continue; }
                istringstream iss(line);   // Создаём поток строк для парсинга
                vector<int> values;       // Вектор для хранения значений в строке
                while (iss >> value) {
                    values.push_back(value);   // Добавляем все числа из строки в вектор
                }
                matrix[i] = values;   // Присваиваем объекту matrix[i] данные из вектора
                n_elem = values.size();   // Количество элементов в текущей строке
                all += n_elem;   // Общее количество элементов
                if (n_elem > max_elem) { max_elem = n_elem - 1; }   // Находим максимальное количество элементов
                i++;
            }
            if ((all - i) % max_elem != 0) {   // Если количество элементов некорректно, выводим ошибку
                out << "ERROR" << endl;
                delete[] matrix;  // Освобождаем память
                return -1;
            } else {
                // Сортируем каждый объект в массиве matrix
                for (int j = 0; j < n; j++) {
                    matrix[j].sort();
                }

                // Сортируем весь массив объектов matrix по первому элементу
                for (int i = 0; i < n - 1; i++) {
                    for (int j = 0; j < n - i - 1; j++) {
                        if (matrix[j].n > 0 && matrix[j + 1].n > 0) {  // Проверяем, что массив не пуст
                            if (matrix[j][0] < matrix[j + 1][0]) {   // Если первый элемент меньше следующего
                                swap(matrix[j], matrix[j + 1]);   // Меняем объекты местами
                            }
                        }
                    }
                }

                // Выводим отсортированные данные в файл
                for (int j = 0; j < n; j++) {
                    matrix[j].print(out);   // Печатаем каждый объект в файл
                }
                out << endl;   // Перенос строки в конце
            }
        }
        in.close();   // Закрываем входной файл
    }

    delete[] matrix;   // Освобождаем память, выделенную для массива matrix
    out.close();   // Закрываем файл для записи
    return 0;   // Завершаем программу
}

/*

Краткое объяснение кода:

Класс T:

Это класс, который моделирует структуру данных, состоящую из целого числа P, массива целых чисел v и их количества n.

В классе есть несколько конструкторов:

Один для инициализации с переданным числом P и размером массива n.

Один по умолчанию, который инициализирует объект нулями.

Конструктор копирования, чтобы создать новый объект на основе существующего.

Конструктор, который принимает vector<int>, и инициализирует объект на основе данных вектора.

Реализованы операторы индексации (operator[]) для доступа к элементам массива.

Метод sort сортирует элементы массива в зависимости от значения P. Если P == 1, сортировка идет по убыванию, если P != 1 — по возрастанию.

Метод print выводит содержимое объекта в поток, например, в файл.

Основная функция:

Открывается файл data.dat для чтения и файл data.res для записи.

В цикле for (int I = 0; I < 2; I++) происходит два этапа обработки:

В первом этапе считается количество строк в файле и создается массив объектов типа T размером n.

Во втором этапе загружаются данные в массив объектов matrix, каждый из которых инициализируется на основе данных из строки файла. Для каждого объекта вызывается метод sort, а затем весь массив сортируется по первому элементу каждого объекта.

Если данные в файле не корректны, выводится ошибка.

В конце данные выводятся в файл data.res в отсортированном виде.

Основные моменты:

Класс T управляет памятью динамически для массива v, освобождая память через деструктор и метод Clean.

Конструктор и методы класса обеспечивают корректную работу с памятью, предотвращая утечку ресурсов.

Входной файл (data.dat) обрабатывается построчно, где каждая строка преобразуется в вектор целых чисел, который затем используется для инициализации объектов.

Массив объектов сортируется как по элементам внутри объектов, так и по внешним параметрам (первый элемент каждого объекта).






*/