#include <iostream> // Подключаем библиотеку для ввода-вывода
#include <fstream>  // Подключаем библиотеку для работы с файлами
#include <vector>   // Подключаем библиотеку для работы с векторами
#include <algorithm> // Подключаем библиотеку для алгоритмов (например, сортировка)
#include <sstream>  // Подключаем библиотеку для работы с потоками строк
using namespace std; // Используем стандартное пространство имен

// Определяем класс T
class T 
{
 public:
  int P{}; // Переменная P, инициализированная нулем
  vector<int> data; // Вектор для хранения данных (целых чисел)

  // Метод для сортировки строки данных
  void sortRow() 
  {
   // Если P равно 1, сортируем по возрастанию
   if (P == 1) {
       sort(data.begin(), data.end());
   } else { // В противном случае сортируем по убыванию
       sort(data.begin(), data.end(), greater<int>());
   }
  }

  // Метод для вывода данных в файл
  void print(ofstream &fout) const 
  {
   fout << P; // Сначала выводим значение P
   for (int x : data) { // Проходим по всем элементам вектора data
       fout << ' ' << x; // Выводим каждый элемент с пробелом
   }
   fout << '\n'; // Переход на новую строку после вывода всех данных
  }
};

// Функция для сравнения объектов класса T по значению P (по убыванию)
bool compareByP(const T &a, const T &b) {
    return a.P > b.P; // Возвращает true, если P первого объекта больше P второго
}

int main() 
{
    ifstream fin("data.dat"); // Открываем файл для чтения данных
    ofstream fout("data.res"); // Открываем файл для записи результатов
    if (!fin) { // Проверяем, удалось ли открыть файл для чтения
        fout << "error"; // Если нет, записываем сообщение об ошибке в выходной файл
        return 0; // Завершаем программу
    }

    vector<T> rows; // Вектор для хранения объектов класса T
    string line; // Строка для чтения данных из файла

    while (getline(fin, line)) { // Читаем файл построчно
        if (line.empty()) continue; // Пропускаем пустые строки
        istringstream iss(line); // Создаем поток ввода из строки
        T temp; // Создаем временный объект класса T

        if (!(iss >> temp.P)) continue; // Читаем значение P, если не удалось - пропускаем строку
        
        int x; // Переменная для хранения считываемого значения
        while (iss >> x) temp.data.push_back(x); // Читаем остальные числа и добавляем их в вектор data

        if (!temp.data.empty()) // Если вектор data не пустой
            rows.push_back(temp); // Добавляем временный объект в основной вектор rows
    }

    if (rows.empty()) { // Если вектор rows пустой после обработки файла
        fout << "no empty"; // Записываем сообщение о пустом файле в выходной файл
    }

    for (auto &r : rows) { // Проходим по всем объектам вектора rows
        r.sortRow(); // Сортируем данные в каждом объекте
    }

    sort(rows.begin(), rows.end(), compareByP); // Сортируем вектор rows по значению P

    for (const auto &r : rows) { // Проходим по отсортированным объектам
        r.print(fout); // Печатаем каждый объект в выходной файл
    }

    return 0; // Завершаем программу успешно
}
